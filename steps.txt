SECTION - 6

1. app.js
2. npm install express
3. npm install nodemon --save-dev
4. "start": "nodemon app.js --inspect"
5. Handle POST - req.body (app.use(express.json() and app.use(express.urlencoded({ extended: true }))))
6. npm install morgan --> app.use(morgan('dev'))
7. Mount router
- app.get(< path >, callback)
- app.route(< path >).get(callback)
- app.use(< path >, router)
--> router.route(< sub - path>).get(callback)
8. app.js, server.js, controllers (tourController.js), routes (tourRoutes.js)
9. Use param middleware for validation
10. Chaining multiple middleware functions
11. Serving static files: app.use(express.static(< path >))
12. Environment variables: process.env
--> NODE_ENV=development nodemon server.js --inspect
--> Use config.env
npm install dotenv
dotenv.config({ path: < path > })
13. morgan --> run on development environment

SECTION - 8

1. Connect database with the Express Application
npm install mongoose
--> Mongoose --> ODM --> Object Data Modeling
--> Configuration: Database's password <PASSWORD>, Database's name
Options: { useNewUrlParser: true, useUnifiedTopology: true }
2. Create Schema and Model
3. MVC Architecture - models Folder
4. CRUD operations with real database
- Create --> model.create
- Read --> model.find, model.findById
- Update --> model.findByIdAndUpdate
- Delete --> model.findByIdAndDelete
5. Modeling the tours
6. Write script to import development data
--> import-dev-data.js
--> model.create(array)
--> model.deleteMany
process.argv
process.exit()
--import
--delete
7. Query string --> ?a=1&b=2 --> req.query
- Special query fields (page, sort, limit, fields)
- No need to exclude fields in query in Mongoose version 6 and above
--> Mongoose only cares if fields defined in Schema
- Understance chaining query
8. Advanced filtering
field[gt] = number
--> query throw CastError
9. Sorting -- 1 or more fields
--> By default, sort using _id --> more efficient
10. Limit field --> Project --> model.select
11. Pagination
12. Aliasing --> 5 best cheap tours --> sort=-ratingAverage,price
--> Middleware --> aliasTopTours
13. API Features
--> APIFeatures as the async function returning class APIFeatures
14. Aggregate Pipeline
--> getTourStats --> model.Aggregate
- $match
- $group
- $sort
- $match
--> Unwinding --> getMonthlyPlan
{ a: [1, 2, 3] }
-- Result --
{ a: 1 }, { a: 2 }, { a: 3 }
15. Virtual properties
schema definition
schema options --> {
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  id: false,
}
16. Middleware --> pre and post hooks (this vs docs)

-- Document --
npm install slugify
--> 'save' acts on .save() and .create() --> also works with findByIdAndUpdate
--> this --> document
Schema --> slug: { type: String }

-- Query --
--> /^find/
--> this --> query
--> post --> docs
Schema --> secretTour: { type: Boolean, default: false }

- Aggregation --> Exclude secretTour

17. Validation --> Built-in & Custom
Compare value A with value B --> Can not update value A and value B at once
--> npm install validator
--> use regex to check if name only contains space and letter

SECTION - 9

1. Unhandled Routes
app.all('*', callback) --> status: fail
2. Global Error Handling Middleware --> Seaparation of Concerns --> status: error
--> Operational Errors (Exceptions)
--> Programming Errors
--> app.use((error, req, res, next) --> 4 arguments --> Express knows that this is Gloabl Error Handling Middleware)
--> next(< error >) --> Global Error Handling Middleware
3. Custom Errors
appError.js --> AppError --> statusCode, status, message
isOperational = true
Error.captureStackTrace(this, this.constructor)
errorController.js --> globalErrorHandler
new AppError vs new Error
4. catchAsync.js
5. 404 Not Found Errors
6. Errors: Development vs Production
--> Operational Error
7. Operational Error
Invalid ID (CastError)
Duplicate value --> code = 11000
ValidationError
8. Unhandled Rejections --> Wrong DB password, etc,... --> Asynchronous
process.exit(0 | 1); 0 --> Success; 1 --> Exception
9. Uncaught Exceptions

SECTION - 10

1. Model and Create Users
--> npm install validator
2. Create User --> authController.js
--> signup --> convert password and passwordConfirm to String
3. Manage Password --> password encryption / password hashing
Create --> Schema Validation --> Pre hook --> Main query --> Post hook --> Send response
--> passwordConfirm validation --> set undefined --> not get save into database
--> Encrypt password
--> npm install bcryptjs --> bcrypt implementation for Javascript
--> bcryptHash
4. JWT
Signing up Users
--> npm install jsonwebtoken
--> signJWT
Logging in Users --> bcryptCompare
--> Sign token if user exists and password is correct (email and password)
- Check if email and password exist
- Check if email - user exists and password is correct --> password { select: false } --> select('+password')
- If everything ok, send token
--> select('password') --> select only field password
--> select('+password') --> select password (add up)
--> correctPassword --> bcrypt.compare
5. Protect Tour Routes --> 401 --> Unauthorized
--> Setting headers in Postman
--> Check authorization --> req.headers.authorization.startsWith('Bearer')
--> Get token --> Verify token --> decoded { id, iat, exp }
--> Handle JWT error --> Invalid JWT and Expired JWT (90d or 5)
JsonWebTokenError
TokenExpiredError
--> Check if user still exists
--> Check if user changed password after JWT was issued --> changePassword
passwordChangedAt { type: Date }
--> Grant access to protected routes --> req.user = currentUser --> next()
--> req travels from middleware to the next one --> put data on req
6. Advanced Postman setup --> Environment variables
--> {{URL}}
--> {{jwt}} --> Postman --> Tests --> pm.environment.set("jwt", pm.response.json().token);
7. Authorization: User - Roles and Permissions --> 403: Forbidden
role { type: String, enum: ['user', 'guide', 'lead-guide', 'admin'], default: 'user' }
protect --> restrictTo --> main route (restrictTo('admin', 'lead-guide'))
8. Reset Token --> forgotPassword (POST) --> resetPassword (PATCH)
+++ forgotPassword +++
--> createPasswordResetToken --> crypto.randomBytes & crypto.createHash
--> passwordResetToken { type: String, select: false }, passwordResetExpires { type: Date, select: false }
--> resetToken & passwordResetToken
--> modify document --> save document --> document.save({ validateModifiedOnly: true })
--> create (new fields) --> update(old fields) --> save (add new fields)
+++ send reset token via email +++
--> npm install nodemailer --> configure to send email in NodeJS
--> create transporter --> configure options --> send email
--> user Mailtrap to send email
--> handle error sending email
+++ resetPassword +++
--> get email & token --> hashed token --> find user { email, passwordResetToken, passwordResetExpires }
--> check password and passwordConfirm --> validate --> save
--> update passwordChangedAt --> this.isModified(< field >) & this.isNew
--> send jwt
9. Update user password
--> user 'save' instead of 'findByIdAndUpdate' case 'findByIdAndUpdate' has some quirk with validation
--> createSendToken
10. Update user's data --> updateMe --> use findByIdAndUpdate --> use filterObject
11. Delete user
--> active { type: Boolean, default: true, select: false } --> deleteMe --> active = false
--> user query middleware to prevent finding inactive user
10. + 11. route /me for both update and delete
GDPR --> General Data Protection Regulation
12. Security
--> Compromised Database
--> Brute Force Attacks
--> Cross-site Scripting (XSS) Attacks
--> Denial Of Service (DOS) Attacks
--> NoSQL Query Injection
...
12.1. Sending JWT via Cookie
--> JWT_COOKIE_EXPIRES_IN
--> Remove password when create new user
12.2. Rate limiting
--> npm install express-rate-limit --> rateLimit
--> configure limiter --> app.use('/api', limiter);
12.3. Security HTTP Headers
--> npm install helmet --> helmet
--> app.use(helmet()) --> set headers --> place on top of middleware stack
--> Limit data from body --> app.use(express.json({ limit: '10kb' }));
--> CORS --> Whho can use API
12.4 Data sanitization
--> Defend against NoSQL Query Injection --> npm install mongo-express-sanitize --> mongoSanitize
--> "email": { "$gt": "" }
--> Defend against Cross - Site Scripting --> npm install xss-clean --> xss
--> "name": "<div></div>"
(
  app.use(express.json({ limit: '10kb' }));
  app.use(express.urlencoded({ extended: true }));
) --> Recieve data
--> Clean data from malicious code
12.5. Prevent parameter pollution
--> sort&sort
--> npm install hpp
--> app.use(hpp({
  whitelist: ['duration', 'ratingsQuantity', 'ratingsAverage',
  'maxGroupSize', 'difficulty', 'price']
}));

SECTION - 11

1. Data Modeling
--> Unstructured data by real world scenario --> Structure --> Logical data model in database
1.1. Types of relationships
--> 1 : 1
--> 1 : Many ( Few | Many | Ton )
--> Many : Many (Few | Few)
1.2. Referencing v/s Embedding (Normalization v/s Denormalization)
1.3. Embed or Reference --> A practical framework
--> 1. Relationship type (How two datasets are related to each other)
--> Embed (1 : Few | 1 : Many)
--> Reference( 1 : Many | 1 : Ton | Many : Many )
--> 2. Data access patterns (How often data is read or written. Read/Write ratio)
--> Embed --> High Read/Write ratio
--> Reference --> Low Read/Write ratio
--> 3. Data closeness (How 'much' the data is related. How we want to query)
--> Embed --> Datasets really belong together
--> Reference --> We frequently need to query datasets on their own
1.4. Types of Referencing
--> 1. Child Referencing --> 1 : Few
--> 2. Parent Referencing --> 1 : Many | 1 : Ton
--> 3. Two - way Referencing --> Many : Many
2. Data Model of Natours --> Image in ./study/Section-11
3. Geospatial Data --> Longitude & Latitude Coordinates describe places on Earth
--> MongoDB uses special data format called GeoJSON
--> specify startLocation & locations
--> GeoJSON --> Longitude --> Latitude
--> GoogleMap --> Latitude --> Longitude
--> documents in array (for example in locations) with automatically created _id
--> see this pattern [{}, {}, {},...] --> Mongoose automatically add _id to objects
--> import "tours.json"
4. Modeling Tour Guides --> Embedding v/s Referencing
+++ Embedding +++
--> guides: { type: Array }
--> Create: ["id", "id", "id",...]
+++ Referencing +++
--> [
  {
    type: mongoose.Schema.ObjectId,
    ref: 'User' --> Same name as User model --> mongoose.model('User', schema, colectionName)
  }
]
--> Create: ["id", "id", "id",...]
5. Populate Tour Guides (Referencing)
--> getTour --> Tour.findById().populate(< field >);
populate({
  path: < field >,
  select: '-__v -passwordChangedAt'
  match: { < field >: < value > }
})
--> populate --> create new query behind the scene --> performance
--> .exec() => return a promise
--> either call next or return a promise in pre & post middleware
await User.find({ _id: { $in: [id] } });
--> test with deleted user
6. reviewModel.js
Review --> review / rating / createdAt/ ref to tour / ref to user
--> {
  type: mongoose.Schema.ObjectId,
  ref: 'Tour',
  required: [true, 'Review must belong to a tour!']
}
--> Create: "id"
--> Prepare for virtual properties
{
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  id: false
}
7. Creating and Getting Reviews
--> getAllReviews
--> protect, restrictTo('user'), createNewReview
--> get userId through protect
8. Populate Reviews
--> populate({ path: 'field1 field2' }) --> can not select fields
--> populate({ path: 'field1' }).populate({ path: 'field2' })
9. Virtual Populate: Tours and Reviews
reviews --> parent reference --> tours
tours don't know about their reviews --> user Virtual Populate to get tours's reviews
foreign field & local field
tourSchema.virtual('reviews', {
  ref: 'Review',
  localField: '_id',
  foreignField: 'tour'
});
--> Implement Virtual Populate on getOneTour --> .populate('reviews')
--> create populate chain --> turn off tour populate --> depends on how application works

10. Simple Nested Routes
POST /tours/:id/reviews --> create review of tour with id and user from login
--> Implement in tourRoutes
--> protect --> restrictTo('user') --> createNewReview
--> get userId from protect --> find tour --> create review
GET /tours/:id/reviews --> get all reviews of tour with id
GET /tours/:tourId/reviews/reviewId --> get review with reviewId of tour with tourId
11. Nested Routes with Express
router.use(< path >, < route >)
--> tourRoutes.js --> app.use('/:tourId/reviews', reviewRouter);
const reviewRouter = express.Router({ mergeParams: true });
--> Each router has access to the parameters of their specific rotues
--> { mergeParams: true } --> access to tourId
/tours/:tourId/reviews v/s /reviews
--> check req.params.tourId --> not req.params.tourId --> req.body.id
--> check tour exists
--> create review for tour
12. Nested Get Endpoint
--> Get all reviews {} and all reviews of a tour { tour: tourId }

13. Building Handler Factory Functions --> handlerFactory.js
--> Factory Function now returns a handler for controller --> put in controller folder
--> In Factory Function set argument dataName = null --> use dataName ? dataName : Model.modelName;
+++ Delete +++
--> const deleteOne = Model => handler
--> Implement on Tours --> Only Admin can delete a tour
--> Implement on Users --> Admin & User --> checkWhoDeleteUser --> convert id to string to compare
+ Admin can delete every user
+ User can only delete his own account
--> Implement on Reviews
+ Admin can delete every review
+ User can only delete his own review
+ User of review is deleted problem --> checkWhoDeleteReview \
--> Check if user exists (in cas admin delete review) --> deleted user --> populate null
+++ Create +++
--> Create tour --> Only Admin can create new tour
--> Create user --> Use /signup
--> Create review --> Only user can create new review
+ Get userId from req.user (protect)
+ Get tourId (/tours/:tourId/reviews or /reviews --> req.body.tour)
+ Create review if user exists
+++ Update +++
--> Update tour --> Only admin can update a tour
--> Update user --> Only update user's name
+ User can only update his own name
+ Chack length fields > 1 --> throw error --> only update user's name
+ Check field < name >
--> Update review
+ User can only update his own review
+ Check if user of that review exists
+ Only update < review > and < rating >
+++ Reading +++
--> const getOne = (Model, popOptions) => handler
--> getAll --> create middleware for getAllReviews
+ findOptions = {} in APIFeatures
--> Can not run find({}) 2 times
--> Every controller has handlers for CRUD operations
+++ Refactor code - handlerFactoryOptions +++

15. /me --> getMe
16. Missing Authentication & Authorization
+++ Tours +++
--> Expose getAllTours
--> Admin & Lead Guide can createNewTour, updateTour, deleteTour
--> Admin, Lead Guide & Guide can getMonthlyPlan
+++ Users +++ --> Authorization Bearer token in Postman --> Use Postman to create documentation
--> Protect Middleware
--> Implement protect for many routes --> userRouter.use(protect) \
--> protect all the routes coming after this point
--> Admin can getAllUsers and getUser
+++ Reviews +++
--> Protect all review routes
--> Tour already populate reviews
--> reviewRouter.use(protect);
17. Import Review and User data --> users.json & reviews.json
--> Import/Delete Tours/Users/Reviews at once --> password in users.json
--> create(data: Array, { validateBeforeSave: false })
18. Improving Read performance with Indexes
--> Statistic query --> await query.explain();
--> tourSchema.index({ price: 1 }); --> index is good for read, but not for create / update
--> Single Index vs Compound Index
--> tourSchema.index({ price: 1, ratingsAverage: -1 })
--> 1 --> Ascending order & -1 --> Descending order
--> tourSchema.index({ slug: 1 })
--> delete index on database
--> When to user indexes --> access pattern (read - write ratio) --> indexes take size and \
affect create / update / delete
---> Compound index also affects on single field

19. Calculating Average Rating on Tours
--> count ratingsAverage & ratingsQuantity on create/update/delete
+++ Review is created +++ --> create --> document middleware
--> Static method --> schema.statics.method --> call staticmethod on Model --> Model.method()
--> schema.statics.calcAverageRatings
--> this.constructor
--> nRating & avgRating
--> this.constructor v/s this.model('Review')
--> aggregate --> _id: '$tour' | null
+++ Review is updated and deleted +++ --> query middleware --> /^findOneAnd/
--> Need to access review document to get tour id
--> findByIdAndUpdate, findByIdAndDelete --> shorthand for findOneAndUpdate, findOneAndDelete
--> in pre --> use this.findOne()
--> no reviews to run Tour.save() using delete
--> Math.round((stats[0]?.avgRating || 4.5) * 10) / 10
20. Preventing Duplicate Reviews
--> Each user should only review each tour once
--> Check index - unique field
--> Use compound index --> reviewSchema.index({ tour: 1, user: 1 }, { unique: true });
--> Round avgRating using feature of Mongoose
ratingsAverage: {
  set: value => Math.round(value * 10) / 10;
}

21. Finding tours within radius
--> router.route('/tours-within/:distance/center/:latlng/unit/:unit') --> getToursWithin
--> {{URL}}api/v1/tours/tours-within/400/center/34.111745,-118.113491/unit/mi
--> startLocation: {
  $geoWithin: {
    $centerSphere: [[lng, lat], radius]
  }
}
--> const radius = unit === 'mi' ? distance / 3963.2 : distance / 6378.1;
--> tourSchema.index({ startLocation: '2dsphere' }); --> help run $centerSphere faster
22. Calculating distances
--> router.route('/distances/:latlng/unit/:unit') --> getDistances
--> $geoNear --> first stage --> need index for geoField
--> aggregate([
  {
    $geoNear: { key, near, distanceField, distanceMultiplier }
  }
])

23. Postman --> Documentation for API
--> variable for password
--> add description for folder, endpoints, parameters --> user markdown
