SECTION - 6 --> Start Building API

1. app.js
2. npm install express
--> Express is a minimal NodeJS framework, a higher level of abstraction
3. npm install nodemon --save-dev
--> "start": "nodemon app.js --inspect"
4. Basic Routing
--> API and The REST Architecture
--> URL and ENDPOINT
5. Handle POST - req.body --> body parser
--> app.use(express.json())
--> app.use(express.urlencoded({ extended: true }))
6. npm install morgan --> app.use(morgan('dev'))
7. Mount router
- app.get(< path >, callback)
- app.route(< path >).get(callback)
- app.use(< path >, router)
--> router.route(< sub - path>).get(callback)
--> app.js, server.js, controllers (tourController.js), routes (tourRoutes.js)
8. Request-Response Cycle and Middleware Stack
--> The essence of Express development is to understand \
the Request-Response Cycle and Middleware Stack

Incoming Request --> Middleware Stack --> Response

9. Use param middleware for validation
10. Chaining multiple middleware functions
11. Serving static files: app.use(express.static(< path >))
12. Environment variables: process.env
--> NODE_ENV=development nodemon --inspect server.js
--> Use config.env
npm install dotenv
dotenv.config({ path: < path > })
13. morgan --> run on development environment

SECTION - 8

1. Connect database with the Express Application
npm install mongoose
--> Mongoose --> ODM --> Object Data Modeling
--> Mongoose is an Object Data Modeling (ODM) library for MongoDB and NodeJS, \
a higher level of abstraction
--> Mongoose Schema: Where we model our data, by describing the structure \
of the data, default values, and validation
--> Mongoose Model: A wrapper for the Schema, providing an interface \
to the database for CRUD operations
--> Configuration: Database's password <PASSWORD>, Database's name
Options: { useNewUrlParser: true, useUnifiedTopology: true }
2. Create Schema and Model
3. MVC Architecture - models Folder
4. CRUD operations with real database
- Create --> model.create
- Read --> model.find, model.findById
- Update --> model.findByIdAndUpdate
- Delete --> model.findByIdAndDelete
5. Modeling the tours
6. Write script to import development data
--> import-dev-data.js
--> model.create(array)
--> model.deleteMany
process.argv
process.exit()
--import
--delete
7. Query string --> ?a=1&b=2 --> req.query
- Special query fields (page, sort, limit, fields)
- No need to exclude fields in query in Mongoose version 6 and above
--> Mongoose only cares if fields defined in Schema
- Understance chaining query
8. Advanced filtering
field[gt] = number
--> query throw CastError
9. Sorting -- 1 or more fields
--> By default, sort using _id --> more efficient
10. Limit field --> Project --> model.select
11. Pagination
12. Aliasing --> 5 best cheap tours --> sort=-ratingAverage,price
--> Middleware --> aliasTopTours
13. API Features
--> APIFeatures as the async function returning class APIFeatures
14. Aggregate Pipeline
--> getTourStats --> model.Aggregate
- $match
- $group
- $sort
- $match
--> Unwinding --> getMonthlyPlan
{ a: [1, 2, 3] }
-- Result --
{ a: 1 }, { a: 2 }, { a: 3 }
15. Virtual properties
schema definition
schema options --> {
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  id: false,
}
16. Middleware --> pre and post hooks (this vs docs)

-- Document --
npm install slugify
--> 'save' acts on .save() and .create() --> also works with findByIdAndUpdate
--> this --> document
Schema --> slug: { type: String }

-- Query --
--> /^find/
--> this --> query
--> post --> docs
Schema --> secretTour: { type: Boolean, default: false }

- Aggregation --> Exclude secretTour

17. Validation --> Built-in & Custom
Compare value A with value B --> Can not update value A and value B at once
--> npm install validator
--> use regex to check if name only contains space and letter

SECTION - 9

1. Unhandled Routes
app.all('*', callback) --> status: fail
2. Global Error Handling Middleware --> Seaparation of Concerns --> status: error
--> Error <--> Exception
--> Operational Errors --> Logic, User,...
--> Programming Errors --> Syntax Error,...
--> Rejection --> Connect to Database fails
--> app.use((error, req, res, next) --> 4 arguments --> Express knows that this is Gloabl Error Handling Middleware)
--> next(< error >) --> Global Error Handling Middleware
3. Custom Errors
appError.js --> AppError --> statusCode, status, message
isOperational = true
Error.captureStackTrace(this, this.constructor)
errorController.js --> globalErrorHandler
new AppError vs new Error
4. catchAsync.js
5. 404 Not Found Errors
6. Errors: Development vs Production
--> Operational Error
7. Operational Error
Invalid ID (CastError)
Duplicate value --> code = 11000
ValidationError
8. Unhandled Rejections --> Wrong DB password, etc,... --> Asynchronous
process.exit(0 | 1); 0 --> Success; 1 --> Exception
9. Uncaught Exceptions

SECTION - 10

1. Model and Create Users
--> npm install validator
2. Create User --> authController.js
--> signup --> convert password and passwordConfirm to String
3. Manage Password --> password encryption / password hashing
Create --> Schema Validation --> Pre hook --> Main query --> Post hook --> Send response
--> passwordConfirm validation --> set undefined --> not get save into database
--> Encrypt password
--> npm install bcryptjs --> bcrypt implementation for Javascript
--> bcryptHash
4. JWT
Signing up Users
--> npm install jsonwebtoken
--> signJWT
Logging in Users --> bcryptCompare
--> Sign token if user exists and password is correct (email and password)
- Check if email and password exist
- Check if email - user exists and password is correct --> password { select: false } --> select('+password')
- If everything ok, send token
--> select('password') --> select only field password
--> select('+password') --> select password (add up)
--> correctPassword --> bcrypt.compare
5. Protect Tour Routes --> 401 --> Unauthorized
--> Setting headers in Postman
--> Check authorization --> req.headers.authorization.startsWith('Bearer')
--> Get token --> Verify token --> decoded { id, iat, exp }
--> Handle JWT error --> Invalid JWT and Expired JWT (90d or 5)
JsonWebTokenError
TokenExpiredError
--> Check if user still exists
--> Check if user changed password after JWT was issued --> changePassword
passwordChangedAt { type: Date }
--> Grant access to protected routes --> req.user = currentUser --> next()
--> req travels from middleware to the next one --> put data on req
6. Advanced Postman setup --> Environment variables
--> {{URL}}
--> {{jwt}} --> Postman --> Tests --> pm.environment.set("jwt", pm.response.json().token);
7. Authorization: User - Roles and Permissions --> 403: Forbidden
role { type: String, enum: ['user', 'guide', 'lead-guide', 'admin'], default: 'user' }
protect --> restrictTo --> main route (restrictTo('admin', 'lead-guide'))
8. Reset Token --> forgotPassword (POST) --> resetPassword (PATCH)
+++ forgotPassword +++
--> createPasswordResetToken --> crypto.randomBytes & crypto.createHash
--> passwordResetToken { type: String, select: false }, passwordResetExpires { type: Date, select: false }
--> resetToken & passwordResetToken
--> modify document --> save document --> document.save({ validateModifiedOnly: true })
--> create (new fields) --> update(old fields) --> save (add new fields)
+++ send reset token via email +++
--> npm install nodemailer --> configure to send email in NodeJS
--> create transporter --> configure options --> send email
--> user Mailtrap to send email
--> handle error sending email
+++ resetPassword +++
--> get email & token --> hashed token --> find user { email, passwordResetToken, passwordResetExpires }
--> check password and passwordConfirm --> validate --> save
--> update passwordChangedAt --> this.isModified(< field >) & this.isNew
--> send jwt
9. Update user password
--> user 'save' instead of 'findByIdAndUpdate' cause 'findByIdAndUpdate' has some quirk with validation
--> createSendToken
10. Update user's data --> updateMe --> use findByIdAndUpdate --> use filterObject
11. Delete user
--> active { type: Boolean, default: true, select: false } --> deleteMe --> active = false
--> user query middleware to prevent finding inactive user
10. + 11. route /me for both update and delete
GDPR --> General Data Protection Regulation
12. Security
--> Compromised Database
--> Brute Force Attacks
--> Cross-site Scripting (XSS) Attacks
--> Denial Of Service (DOS) Attacks
--> NoSQL Query Injection
...
12.1. Sending JWT via Cookie
--> JWT_COOKIE_EXPIRES_IN
--> Remove password when create new user
12.2. Rate limiting
--> npm install express-rate-limit --> rateLimit
--> configure limiter --> app.use('/api', limiter);
12.3. Security HTTP Headers
--> npm install helmet --> helmet
--> app.use(helmet()) --> set headers --> place on top of middleware stack
--> Limit data from body --> app.use(express.json({ limit: '10kb' }));
--> CORS --> Whho can use API
12.4 Data sanitization
--> Defend against NoSQL Query Injection --> npm install express-mongo-sanitize --> mongoSanitize
--> "email": { "$gt": "" }
--> Defend against Cross - Site Scripting --> npm install xss-clean --> xss
--> "name": "<div></div>"
(
  app.use(express.json({ limit: '10kb' }));
  app.use(express.urlencoded({ extended: true }));
) --> Recieve data
--> Clean data from malicious code
12.5. Prevent parameter pollution
--> sort&sort
--> npm install hpp
--> app.use(hpp({
  whitelist: ['duration', 'ratingsQuantity', 'ratingsAverage',
  'maxGroupSize', 'difficulty', 'price']
}));

SECTION - 11

1. Data Modeling
--> Unstructured data by real world scenario --> Structure --> Logical data model in database
1.1. Types of relationships
--> 1 : 1
--> 1 : Many ( Few | Many | Ton )
--> Many : Many (Few | Few)
1.2. Referencing v/s Embedding (Normalization v/s Denormalization)
1.3. Embed or Reference --> A practical framework
--> 1. Relationship type (How two datasets are related to each other)
--> Embed (1 : Few | 1 : Many)
--> Reference( 1 : Many | 1 : Ton | Many : Many )
--> 2. Data access patterns (How often data is read or written. Read/Write ratio)
--> Embed --> High Read/Write ratio
--> Reference --> Low Read/Write ratio
--> 3. Data closeness (How 'much' the data is related. How we want to query)
--> Embed --> Datasets really belong together
--> Reference --> We frequently need to query datasets on their own
1.4. Types of Referencing
--> 1. Child Referencing --> 1 : Few
--> 2. Parent Referencing --> 1 : Many | 1 : Ton
--> 3. Two - way Referencing --> Many : Many
2. Data Model of Natours --> Image in ./study/Section-11
3. Geospatial Data --> Longitude & Latitude Coordinates describe places on Earth
--> MongoDB uses special data format called GeoJSON
--> specify startLocation & locations
--> GeoJSON --> Longitude --> Latitude
--> GoogleMap --> Latitude --> Longitude
--> documents in array (for example in locations) Mongoose automatically created _id
--> see this pattern [{}, {}, {},...] --> Mongoose automatically add _id to objects
--> import "tours.json"
4. Modeling Tour Guides --> Embedding v/s Referencing
+++ Embedding +++
--> guides: { type: Array }
--> Create: ["id", "id", "id",...]
--> Case: Don't specify tour's guides
+++ Referencing +++
--> [
  {
    type: mongoose.Schema.ObjectId,
    ref: 'User' --> Same name as User model --> mongoose.model('User', schema, colectionName)
  }
]
--> Create: ["id", "id", "id",...]
5. Populate Tour Guides (Referencing)
--> getTour --> Tour.findById().populate(< field >);
populate({
  path: < field >,
  select: '-__v -passwordChangedAt'
  match: { < field >: < value > }
})
--> populate --> create new query behind the scene --> performance
--> .exec() => return a promise
--> either call next or return a promise in pre & post middleware
await User.find({ _id: { $in: [id] } });
--> test with deleted user --> []

6. reviewModel.js
Review --> review / rating / createdAt/ ref to tour / ref to user
--> {
  type: mongoose.Schema.ObjectId,
  ref: 'Tour',
  required: [true, 'Review must belong to a tour!']
}
--> Create: "id"
--> Prepare for virtual properties
{
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  id: false
}
7. Creating and Getting Reviews
--> getAllReviews
--> protect, restrictTo('user'), createNewReview
--> get userId through protect
8. Populate Reviews
--> populate({ path: 'field1 field2' }) --> can not select fields
--> populate({ path: 'field1' }).populate({ path: 'field2' })
9. Virtual Populate: Tours and Reviews
reviews --> parent reference --> tours
tours don't know about their reviews --> user Virtual Populate to get tours's reviews
foreign field & local field
tourSchema.virtual('reviews', {
  ref: 'Review',
  localField: '_id',
  foreignField: 'tour'
});
--> Implement Virtual Populate on getOneTour --> .populate('reviews')
--> create populate chain --> turn off tour populate --> depends on how application works
--> populate on middleware and populate on main query at the same time

10. Simple Nested Routes
POST /tours/:id/reviews --> create review of tour with user from login
--> Implement in tourRoutes
--> protect --> restrictTo('user') --> createNewReview
--> get userId from protect --> find tour --> create review
GET /tours/:id/reviews --> get all reviews of tour with id
GET /tours/:tourId/reviews/reviewId --> get review with reviewId of tour with tourId
11. Nested Routes with Express
router.use(< path >, < route >)
--> tourRoutes.js --> app.use('/:tourId/reviews', reviewRouter);
const reviewRouter = express.Router({ mergeParams: true });
--> Each router has access to the parameters of their specific rotues
--> { mergeParams: true } --> access to tourId
/tours/:tourId/reviews v/s /reviews
--> check req.params.tourId --> not req.params.tourId --> req.body.id
--> check tour exists
--> create review for tour
12. Nested Get Endpoint
--> Get all reviews {} and all reviews of a tour { tour: tourId }

13. Building Handler Factory Functions --> handlerFactory.js
--> Factory Function now returns a handler for controller --> put in controller folder
--> In Factory Function set argument dataName = null --> use dataName ? dataName : Model.modelName;

+++ Delete +++
--> const deleteOne = Model => handler
--> Implement on Tours --> Only Admin can delete a tour
--> Implement on Users --> Admin & User --> checkWhoDeleteUser --> convert id to string to compare
+ Admin can delete every user
+ User can only delete his own account
--> Implement on Reviews
+ Admin can delete every review
+ User can only delete his own review
+ User of review is deleted problem --> checkWhoDeleteReview \
--> Check if user exists (in case admin delete review) --> deleted user --> populate null

+++ Create +++
--> Create tour --> Only Admin can create new tour
--> Create user --> Use /signup --> 501 --> Not Implemented
--> Create review --> Only user can create new review
+ Get userId from req.user (protect)
+ Get tourId (/tours/:tourId/reviews or /reviews --> req.body.tour)

+++ Update +++
--> Update tour --> Only admin can update a tour
--> Update user --> Only update user's name
+ User can only update his own name
+ Check length fields > 1 --> throw error --> only update user's name
+ Check field < name >
--> Update review
+ User can only update his own review
+ Check if user of that review exists
+ Only update < review > and < rating >

+++ Reading +++
--> const getOne = (Model, popOptions) => handler
--> getAll --> create middleware for getAllReviews
+ findOptions = {} in APIFeatures
--> Can not run find({}) 2 times
--> Every controller has handlers for CRUD operations

15. /me --> getMe
16. Missing Authentication & Authorization
+++ Tours +++
--> Expose getAllTours
--> Admin & Lead Guide can createNewTour, updateTour, deleteTour
--> Admin, Lead Guide & Guide can getMonthlyPlan
+++ Users +++ --> Authorization Bearer token in Postman --> Use Postman to create documentation
--> Protect Middleware
--> Implement protect for many routes --> userRouter.use(protect) \
--> protect all the routes coming after this point
--> Admin can getAllUsers and getUser
+++ Reviews +++
--> Protect all review routes
--> Tour already populate reviews
--> reviewRouter.use(protect);
17. Import Review and User data --> users.json & reviews.json
--> Import/Delete Tours/Users/Reviews at once --> password in users.json
--> create(data: Array, { validateBeforeSave: false })
18. Improving Read performance with Indexes
--> Statistic query --> await query.explain();
--> tourSchema.index({ price: 1 }); --> index is good for read, but not for create / update
--> Single Index vs Compound Index
--> tourSchema.index({ price: 1, ratingsAverage: -1 })
--> 1 --> Ascending order & -1 --> Descending order
--> tourSchema.index({ slug: 1 })
--> delete index on database
--> When to user indexes --> access pattern (read - write ratio) --> indexes take size and \
affect create / update / delete
---> Compound index also affects on single field

19. Calculating Average Rating on Tours
--> count ratingsAverage & ratingsQuantity on create/update/delete

+++ Review is created +++ --> create --> document middleware
--> Static method --> schema.statics.method --> call staticmethod on Model --> Model.method()
--> schema.statics.calcAverageRatings
--> this.constructor
--> nRating & avgRating
--> this.constructor v/s this.model('Review')
--> aggregate --> _id: '$tour' | null

+++ Review is updated and deleted +++ --> query middleware --> /^findOneAnd/
--> Need to access review document to get tour id
--> findByIdAndUpdate, findByIdAndDelete --> shorthand for findOneAndUpdate, findOneAndDelete
--> in pre --> use this.findOne()
--> no reviews to run Tour.save() using delete
--> Math.round((stats[0]?.avgRating || 4.5) * 10) / 10

20. Preventing Duplicate Reviews
--> Each user should only review a certain tour once
--> Check index - unique field
--> Use compound index --> reviewSchema.index({ tour: 1, user: 1 }, { unique: true });
--> Round avgRating using feature of Mongoose
ratingsAverage: {
  set: value => Math.round(value * 10) / 10;
}

21. Finding tours within radius
--> router.route('/tours-within/:distance/center/:latlng/unit/:unit') --> getToursWithin
--> {{URL}}api/v1/tours/tours-within/400/center/34.111745,-118.113491/unit/mi
--> startLocation: {
  $geoWithin: {
    $centerSphere: [[lng, lat], radius]
  }
}
--> const radius = unit === 'mi' ? distance / 3963.2 : distance / 6378.1;
--> tourSchema.index({ startLocation: '2dsphere' }); --> help run $centerSphere faster
22. Calculating distances
--> router.route('/distances/:latlng/unit/:unit') --> getDistances
--> $geoNear --> first stage --> need index for geoField
--> aggregate([
  {
    $geoNear: { key, near, distanceField, distanceMultiplier }
  }
])

23. Postman --> Documentation for API
--> variable for password
--> add description for folder, endpoints, parameters --> user markdown

--- Reinforce knowledge before moving on

1. Front-end v/s Back-end
--> Back-end
+ Static Website
+ Dynamic Website
+ API Website

--> How the Web works?

2. The Event - Driven Architecture

Emitter -- [Emit events] --> Listener -- [Calls] --> Attached callback function
[         Observer pattern           ]

3.1. The CommonJS Module System

--> Each Javascript file is treated as a separate module
--> NodeJS uses CommonJS Module System: require(), exports, module.exports
--> ES Module System (EcmaScript Module System) is used in browsers: import/export
--> There have been attempts to bring ES modules to NodeJS (.mjs)

3.2. Require() a module

Resolving & Loading --> Wrapping --> Execution --> Returning Exports --> Caching

--> Resolving & Loading (Core modules / Developer modules / 3rd-party modules - NPM)
--> Path resolving
1. Start with Core modules
2. If begins with './' or '../' --> Try to load Developer modules
3. If no file found --> Try to find folder with index.js in it
4. Else --> Go to node_modules/ and try to find module there

--> Wrapping
(function (exports, require, module, __filename, __dirname) {
  // Module code lives here
});

--> Execution

--> Returning Exports
--> require function returns exports of the required module

--> Caching

4. NodeJS --> V8 Engine --> libuv (event loop & thread pool - threads)

--> A process --> A program in execution
--> Node Process --> First off, when we use Node on a computer, \
it means that there is a Node process running on that computer

--> NodeJS (Single Thread) \
--> Initialize program \
--> Execute "top-level" code \
--> Require moduels \
--> Register event callbacks \
--> Event Loop

5. NodeJS Event Loop

--> Callback queues
1. Expired timer callbacks --> Timer queue
2. I/O polling and callbacks --> IO queue
--- I/O Polling
3. setImmediate callbacks --> Check queue
4. Close callbacks (Server or Web Socket shuts down) --> Close queue

--> Check Microtask Queue after every callback

--> Microtask queues
1. process.nextTick() queue
2. Other microtasks queue (Resoleved promises)

---

SECTION - 12 --> Server-Side Rendering

1. Setting up Template Engine in Express --> Setting up Pug in Express

1.1. Tell Express which Template Engine we want to use
--> Template Engine --> allow us to create a template and then easily \
fill up that template with our data
--> npm install pug
--> app.set('view engine', 'pug');
--> Express automatically supports the most common engines out of the box
1.2. Define where these files are actually located in our file system
--> Pug templates are actually called views in Express --> create views folder
--> app.set('views', path.join(__dirname, 'views'))
--> create file in views --> < name >.pug
1.3. Define a route
--> res.status.render(< name >);
--> 304 --> Not Modified

2. First Steps with Pug

--> What is Pug?
--> In essence, Pug is a simple whitespace sensitive syntax for writing HTML, \
so that really the gist of what it is
--> Writing HTML using their name and indentation

--> link favicon --> img/favicon.png
--> link css file --> css/style.css
--> attributes
--> style.css file actually get loaded from the css folder automatically \
because each asset actually triggers its own HTTP requests
--> Handled by app.use(express.static(< path >))

--> Pass data into a Pug template
--> res.status(200).render(< name >, < options >);
--> Variables are passed into a Pug template called locals
--> options = { tour: 'The Park Camper', user: 'Jonas' }

--> 3 ways of writing code in a Pug template

--> 1. Buffered Code
--> h1= tour --> buffered code
--> write simple code in buffered code --> h2= user.toUppercase()

--> 2. Unbuffered Code --> Not going to add anything to the output
--> Syntax of Unbuffered Code: - const x = 9;
- const x = 9;
h2= 2 * x

--> 3. Interpolation
--> Looks like Template String in ES6
--> Natours | #{tour} --> Natours | The Forest Hiker

--> create comments in Pug template \
// --> HTML comment
//- --> Pug comment

--> https://html2pug.vercel.app/ --> Use this site to convert HTML to Pug
--> https://html-to-pug.com/

3. Create Base Template

--> Base template
--> The template upon which all other templates will be based on later

--> BEM --> Block__Element--Modifier
--> div --> the standard block element in HTML --> .

--> Convert HTML to Pug template

--> HEADER
--> Don't use form at this point
--> Commnent out nav user

--> CONTENT
--> Just create a Skeleton at this point
section.overview
  h1 = tour

--> FOOTER
--> li: a(href='#') Link --> Works just find as long as \
there is no new line with indentation
| --> line continue
--> cta --> call to action

4. Include Files into Pug Template

--> Include one template into another template
--> Good practice --> Prefix these files that only serve \
for being included with an underscore
--> _header.pug --> _footer.pug
--> base.pug --> include _header --> include _footer

5. Extend Base Template with Blocks

--> extends --> use the same base layout for every single page
--> overview.pug --> tour.pug
--> app.get('overview', (req, res) => {
  res.status(200).render('overview', {
    title: 'All Tours'
  });
});
--> app.get('tour', (req, res) => {
  res.status(200).render('tour', {
    title: 'The Forest Hiker'
  });
});

--> Inject the content into the base template (the parent template) \
--> This process is then called extending
--> So whenever the overview template is rendered, we then take \
the base template and fill it up with the content of this file, \
--> so we extend it

--> base.pug
block content
  h1 This is a placeholder heading
--> overview.pug
---
extends base

block content
  h1 This is the tour overview
--
--> Can only extend one base but have many blocks
--> With extends, now we can use different routes like 'overview' and 'tour' \
and still have the code in 'base' route

file extends --> base file --> base included

6. Setting up the Project Structure --> MVC for views

7. Building the Tour Overview

--> 1. Getting tour data from collection
--> 2. Render
{ title: 'All Tours', tours }
--> each tour in tours --> builtin loop in Pug
--> main.main
---
tour.name (2) --> template string v/s interpolation
tour.imageCover
--> .card__details
`${tour.difficulty} ${tour.duration}-day tour`
tour.summary
tour.startLocation.description
tour.startDates[0].toLocaleString('en-us', {
  month: 'long', year: 'numeric'
})
`${tour.locations.length} stops`
`${tour.maxGroupSize} people`
`$${tour.price}`
`${tour.ratingsAverage}`
`rating (${tour.ratingsQuantity})`
`/tours/${tour.slug}` --> relative URL
| --> empty piped lane

8. Building the Tour Page

--> get tour using :slug
--> populate({
  path: 'reviews',
  select: 'review rating user'
})
--> Fix load CSS file, images,...

--> Build template

--> Header section
`/tours/img/${tour.imageCover}`
tour.name (2)
tour.duration
tour.startLocation.description
--> mixin headingBox(text, icon)

--> Description section
--> mixins --> basically reusable pieces of code
--> preprocessor --> In computer science, a preprocessor (or precompiler) \
is a program that processes its input data to produce output \
that is used as input in another program
---
mixin overviewBox(label, text, icon)
---
--> test include mixin
- const date = tour.startDates[0].toLocaleString('en-us', {
  month: 'long',
  year: 'numeric'
})
tour.difficulty
tour.maxGroupSize
tour.ratingsAverage / tour.ratingsQuantity

each guide in tour.guides
guide.name (2)
`img/users/${guide.photo}`
guide.role
- if (guide.role === 'lead-guide')
  span Lead guide
- if (guide.role === 'guide')
  span Tour guide

`About ${tour.name} tour`
- const paragraphs = tour.description.split('\n')
each p in paragraphs
  p.description__text= p

--> Images section
each img, i in tour.images
`/img/tours/${img}`, `${tour.name} Tour ${i + 1}`
class=`picture-box__img--${i + 1}` --> test #{}

--> Reviews section
each review in tour.reviews
  +reviewCard(review)
mixin reviewCard(review)
review.user.name (2)
`/img/users/${review.user.photo}`
review.review
--> fix All Tours link
each star in [1, 2, 3, 4, 5]
  `${review.rating >= star ? 'active' : 'inactive'}`

--> Call to Action section
`img/tours/${tour.images[1]}` alt='Picture tour'
tour.duration

9. Including a Map with Mapbox

--> Fix title of Website
--> { title: `${tour.name} Tour` }

--> Library Mapbox --> runs in the front-end

9.1 JS file

---
block head
block append head
  script(defer, src='/js/mapbox.js')
---
--> Add at the end of the block

--> Instead of calling API again in JS file
--> #map --> data-locations=`${JSON.stringify(tour.locations)}`
--> Get locations in JS file
--> Run JS file with async, defer or using DOMContentLoaded

9.2 Mapbox

--> SDK --> Software Development Kit
--> A software development kit (SDK) is a set of tools \
provided by the manufacturer of (usually) a hardware platform, \
operating system (OS), or programming language

--> Create account
--> SDK --> JS Web --> CDN --> Link
--> npm i helmet@3.23.3 --> Cannot load mapboxgl

--> Create token --> Include token
--> Desplay default Map

--> Design in Mapbox Studio
--> Use Style URL

--> GPS --> Global Positioning System

--> Create Marker --> Add Marker --> Add Popup \
--> Extend map bound to include current location
--> Style --> Padding

--> Create Popup of Marker

10. Building the Login Screen

--> 'Log into your account'
--> Create link to '/login'

11. Loggin in Users with API

11.1. Login and get cookie
--> HTTP Request or AJAX
--> /js/login.js
--> axios --> error.response.data
--> Cookies
--> The browser sends the cookie along with every new request
--> Back-end
--> In order to get access to the cookies that are in request
--> npm install cookie-parser
--> app.use(cookieParser())
--> req.cookies
--> add using cookie to protect

11.2. Middleware checks if use logged in
--> Server-side Rendering --> Reload on each request --> Using Cookie
--> Client-side Rendering --> No Reload --> Using Authorization

--> This middleware running for each and every single request on our rendered website
--> isLoggedIn --> Only for render pages, no errors!
--> Cookie expired --> Render error?
--> res.locals.user = currentUser; --> Pug template will receive user variable
--> app.use(isLoggedIn)
---
if user
  a.nav__el.nav__el--logout(href='#') Logout
  a.nav__el(href='#')
    img.nav__user-img(src=`/img/users/${user.photo}`, alt=`Photo of ${user.name}`)
    span= user.name.split(' ')[0]
else
  a.nav__el(href='/login') Log in
  a.nav__el.nav__el--cta(href='#') Sign up
---
--> redirect to homepage after logging in
--> Check status is success --> Redirect --> location.assign('/')
--> Is not success --> throw error --> error.response.data.message

window.location.href; // Returns the href (URL) of the current page
window.location.hostname; // Returns the domain name of the web host
window.location.pathname; // Returns the path and filename of the current page
window.location.protocol; // Returns the web protocol used (http: or https:)
window.location.assign; // Loads a new document
window.location.replace; // Replace the current location with new one.

11.3. Alert message and JS Bundling
--> alert.js
--> Parcel --> Blazing fast, zero configuration web application bundler
--> npm install parcel-bundler --save-dev
--> "watch:js": "parcel watch ./public/js/index.js --out-dir ./public/js --out-file bundle.js"
--> "build:js": "parcel build ./public/js/index.js --out-dir ./public/js --out-file bundle.js"
--> index.js
--> run watch:js
--> npm install @babel/polyfill --> import '@babel/polyfill' \
--> use \
+ npm install core-js --> import 'core-js/stable'
+ npm install regenerator-runtime --> import ''

--> export login function
--> axios npm
--> displayMap(locations)
??? fetch the same JS file?
const mapBox, loginForm

--> create alert
--> showAlert(type, message) 'success' | 'error'
--> hideAlert

--- Parcel
1. Building with Parcel and NPM Scripts
npm install parcel --save-dev
npx parcel index.html
--> Running Parcel with NPM Scripts
"start": "parcel index.html"
"build": "parcel build index.html"

2. Configuring Babel and Polyfilling
--> Babel
--> Plugin \
+ Arrow-functions
+ Block-scopred-functions
...
--> Preset --> Basically a bunch of plugins bundled together
@babel/preset-env
--> By default, Parcel is going to use this preset
--> This preset will automatically select which JS features should be compiled \
--> based on browser support
--> Only < 0.25% are not going to be supported by the transpiling \
with this preset here
--> Transpiling v/s Polyfilling
--> Transpile --> ES6 to equivalent ES5 syntax
--> Polyfill --> New ES6 Syntax
npm install core-js
import 'core-js/stable'
npm install regenerator-runtime
import 'regenerator-runtime/runtime' --> Polyfilling async functions

--> Setting up Parcel with FKF project
--> Parcel can bundle SASS --> HTML link to SCSS directly

3. MVC architecture (Structure - Maintainability - Expandability)
--> Structure --> How we organize and divide the code into \
different modules, classes and functions
--> Maintainability --> We need to be able to easily change it in the future
--> Expandability --> We also need to be able to easily add new features
S + M + E --> The perfect Architecture

--> Components of any Architecture
+ Business Logic --> The code solves the actual business problem
+ State --> Essentially stores all the data about the application
--> Be "Single source of truth" --> which should be kept in Sync with the UI \
--> means that if some data changes in the State, then the User Interface should \
reflect that, and the same is true the orther way around
+ HTTP Library --> Responsible for making and receiving AJAX requests
+ Application Logic (Router) --> Code that is only concerned about \
the implementation of application itself --> Navigation, UI events,...
+ Presentation Logic (UI Layer) --> Code that is concerned about the visible part \
of the application --> Essentially displays application state

4. Helpers and Configuration Files
--> config.js --> Put all the variables that should be constants \
and should be reused accross the project
--> helpers.js --> Contain a couple of functions that we reuse \
over and over in our project
---

12. Logging out Users

--> Cookie --> HTTP Only Cookie \
--> Can not manipulate this Cookie in anyway in our browser
--> logout --> send new cookie to override current cookie
--> no need to set secure = true cause there is no sensitive data
---
res.cookie('jwt', 'loggedout', {
  expires: new Date(Date.now() + 10 * 1000),
  httpOnly: true
});
viewRouter.get('/logout', logout);
---
--> Get cookie --> Reload to log out
--> location.reload(true)
--> true --> force a reload from the server and not from browser cache

13. Rendering Error Pages

--> Tour not found with slug --> 404 error
--> Check API or Rendered Website
---
if (req.originalUrl.startsWith('/api'))
else
  res.status(error.statusCode).render('error', {
    title: 'Something went wrong!',
    msg: error.message
  });
---
--> views --> error.pug
--> Error Handling for just API and for just Rendered Website
--> Prod --> not isOperational --> message --> 'Please try again later'

--> Fix error /bundle.js.map not found!
add to watch:js --public-url ./

14. Building User Account Page

--> account.pug
--> mixin navItem(link, text, icon, active)
--> if (user.role === 'admin')
--> value=`${user.name}`
--> `/img/users/${user.photo}` --> case: new user doesn't have any photo
--> user.get('/me', protect, getAccount)
--> protect --> handles login error --> protect v/s isLoggedIn
--> only use protect or isLoggedIn to check
--> protect --> res.locals.user = user
--> title: 'Your account'

15. Updating User Data

--> Specify the POST method right on the form along with the URL \
where the POST request should be sent to
--> Body parser --> app.use(express.urlencoded({ extended: true, limit: '10kb' }))
--> form(action='/submit-user-data', method='POST')
--> name='name', name='email'
--> viewRouter.post('/submit-user-data', protect, updateUserData);
--> Fix login form with '.form--login'

--> After send Post request --> Keep POST with the same data

--> method-override npm package
--> Not a good user experience --> Submit data and then all of a sudden, \
we went to a completely new page

16. Updating User Data with API

--> remove form action and method
--> updateSettings.js
--> checkUpdateUsername --> checkUpdateMe
--> updateUserName --> updateMe

17. Updating User Password with API

--> '.form-user-settings' --> '.form-user-password'
--> updateSettings function
--> await updateSetting --> clear password input field
--> '.btn--save-password'

SECTION - 13

1. Image Uploads using Multer

--> Multer --> a very popular middleware to handle multi-part form data
--> npm install multer
--> Fix checkUpdateMe
--- userRoutes.js
const multer = require('multer');
// const upload = multer({ dest: 'public/img/users' });
const upload = multer({
  dest: path.join(__dirname, '..', 'public', 'img', 'users'),
});
router.patch('/updateMe', upload.single('photo'), updateMe);
---
// req.file v/s req.body
--> body parser is not really able to handle files \
--> the file is not showing up in the body at all
--> new image is created in 'public/img/users'

--> Test mkdirp package
---
const mkdirp = require('mkdirp')
...
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const path = `/images/${req.user._id}/`
    mkdirp(path, err => {
        if (err) return cb(err)
        else cb(null, path)
    });
  },
  filename: (req, file, cb) => {
    cb(null, file.fieldname + '-' + Date.now())
  }
})
---
--> take a look at multer npm

2. Configuring Multer

--> First --> Giving images a better filename --> multer.diskStorage

--> userController.js --> exports.uploadUserPhoto
--> const multerStorage = multer.diskStorage();
--> filename --> user-userid-current_timestamp.file_extension
--> const ext = file.minetype.split('/').at(-1);
--> cb(null, `user-${req.user.id}-${Date.now()}.${ext}`);

--> Second --> Allowing only image files to be uploaded onto our server --> multerFilter
--> Not an image! Please upload only images.

--> const upload = multer({
  storage: multerStorage,
  fileFilter: multerFilter
});

3. Saving Image Name to Database

--> Update photo --> checkUpdateMe.js
--> if (req.file)...

--> Create new user --> userModel.js --> default.jpg
--> photo: {
  type: String,
  default: 'default.jpg'
}

--> Fix AxiosError
{
  name: 'AxiosError',
  code: 'ERR_NETWORK'
}
---
if (error.name === 'AxiosError' && error.code === 'ERR_NETWORK')
  return showAlert(
    'error',
    'Something went wrong! Check your network connection and try again.'
  );
---

4. Resizing Images

--> resizeUserPhoto
--> npm install sharp --> sharp --> image processing library for NodeJS

--> when doing image processing right after uploading a file, \
then it's always best to not even save the file to the disk, \
but instead save it to memory
--> const multerStorage = multer.memoryStorage();
--> this way the image will then be stored as a buffer --> req.file.buffer
--> resizeUserPhoto
--> if there is no photo --> next()
--> else
---
filename = `<>.jpeg` --> used to link database to image in files system
sharp(< buffer >)
  .resize(< witdth >, < height >) 500 / 500
  .toFormat('jpeg')
  .jpeg({ quality: 90 })
  .toFile(`<path>/${filename}`)
---
--> test async

5. Adding Image Uploads to Form

--> If not using API --> enctype='multipart/form-data'

--> input.form__upload(type='file', accept='image/*', id='photo', name='photo')
--> add "multiple" attribute --> choose multiple images
--> label(for='photo') Choose new photo

--> create a multi-part form data
---
const form = new FormData();
form.append('photo', < element >.files[0])
---

--> const link = URL.createObjectURL(file)
--> URL.revokeObjectURL(link)
--> fileReader API --> https://www.youtube.com/watch?v=2okUvC2qBWk

* --> upload new image --> delete old image
---
file.existsSync(< path >)
file.unlinkSync(< path >)
---

6. Uploading Multiple Images

--> Learn how to upload multiple files at the same time and \
and also how to process multiple images at the same time
--> updateTour
--> upload.single
--> upload.array
--> upload.fields
--> maxCount --> error ?
--> uploadTourImages
--> resizeTourImages --> req.files
---
// upload.array(< name >, < maxCount >)
exports.uploadTourImages = upload.fields([
  { name: < name >, maxCount: < number > }
]);
---
--> maxCount error --> multer automatically calls next(error)
{
  "name": "MulterError",
  "code": "LIMIT_UNEXPECTED_FILE"
}

7. Processing Multiple Images

--> fix error --> await sharp in user controller
--> const imageCoverFilename = `tour-${req.params.id}-${Date.now()}-cover.jpeg`;
--> const filename = `tour-${req.params.id}-${Date.now()}-${index + 1}.jpeg`;

8. Building a Complex Email Handler

--> EMAIL_FROM
--> Dev --> MailTrap
--> Prod --> SendGrid
class Email(user, url)
+ to --> user.email
+ firstName --> user.name.split(' ')[0]
+ url --> url
+ from --> `${EMAIL_FROM}`

--> newTransport --> dev v/s prod

--> send(template, subject)

+ Render HTML based on a Pug template
--> views/email/welcome.pug
--> responsive-html-email-template
---
const pug = require('pug');
pug.renderFile('welcome', {
  firstName: this.firstName,
  url: this.url,
  subject
}) --> html
---

+ Define email options
--> npm install html-to-text
---
const htmlToText = require('html-to-text');
text: htmlToText.fromString(html) // deprecated
---

+ Create a transport and send email
---
await this.newTansport().sendMail(options)
---

--> sendWelcome --> this.send('welcome', 'Welcome to the Natours Family!')

9. Email Templates with Pug: Welcome Emails

--> welcome.pug
--> _style.pug
--> baseEmail.pug
subject
firstName
url --> `${req.protocol}://${req.get('host')}/me`
--> authController.js --> signup

10. Sending Password Reset Emails

--> passwordReset.pug

subject
firstName
message --> url
(Website for this action not yet implemented)
`${url}` --> Reset your password
---
async sendPasswordReset() {
  await this.send(
    'passwordReset',
    'Your password reset token (valid for only 10 minutes)'
  );
}
---

11. Sendgrid --> Real Emails

--> mailsac

12. Credit Card Payments with Stripe

--> Settings --> Branding --> #55c57a
--> Developers --> API Keys
+ Publshable Key --> Front-end
+ Secret Key --> Back-end
--> Stripe Checkout

--> Stripe Workflow

--> Backend --> Secret Key --> create Stripe Checkout Session
--> This session is gonna contaion a bunch of data about the object \
that can be purchased

--> Frontend
--> Request Checkout Session
--> Public key --> Charge Credit Card using Session

--> Backend --> Secret Key --> use Striper Webhook to create new Booking

13. Integrating Stripe into the Back-End

--> create API endpoint --> which will create and send back \
a Stripe Checkout Session
--> bookingRoute.js
--> bookingController.js
---
router.get('/checkout-session/:tourId', protect, getCheckoutSession)
// 1. Get the currently booked tour
// 2. Create checkout session
// 3. Create session as response
---
--> npm install stripe
--> STRIPE_SECRET_KEY

--> const session = await stripe.checkout.sessions.create(options)
--> res.status(200).json({ status: 'success', session });

14. Processing Payments on the Front-End

---
if user
  button#book-tour(data-tour-id=`${tour.id}`) Book tour now
else
  a(href='/login') Log in to book tour
---

--> stripe.js --> link
---
const stripe = Stripe(< Publishable Key >);
const bookTour = tourId => {
  1. Get Checkout Session from API
  2. Create checkout form + charge credit card
}
await stripe.redirectToCheckout({
  sessionId: session.data.session.id
});
---

15. Modelling the Bookings

--> tour, user, price, createdAt, paid

16. Creating new Bookings on Checkout Success

--> 127.0.0.1:3000/?params=< params >
--> createBookingCheckout
--> res.redirect(< url >);

17. Redering a User's Booked Tours

--> /my-tours --> getMyTours
---
res.status(200).render('overview', {
  title: 'My Tours',
  tours
});
---

--> _id: { $in: [_id, _id,...] }
--> { $in: [{_id}, {_id}] }

18. Finishing the Bookings API

--> Creating
--> Getting
--> Updating
--> Deleting

19. Final Considerations

CHALLENGES API

- Implement restriction that users can only review a tour that they have actually booked;
+ reviewController.js --> checkTourIsBooked --> await Booking.findOne({ tour: tourId, user: userId })

- Implement nested booking routes: /tours/:id/bookings & /users/:id/bookings
--> Create --> checkNewBooking --> createNewBooking
--> Read
+ Get --> getBooking
+ Get All --> checkGetAllBookings --> getAllBookings
--> Update (< paid > field) --> checkUpdateBooking --> updateBooking
--> Delete --> deleteBooking

- Improve tour dates: add a participants and soldOut field to each date. \
A date then becomes an instance of the tour. Then, when a user boooks, \
they need to select one of the dates. A new booking will increase the number \
of participants in the date, until it is booked out(participants > maxGroupSize). \
So when a user wants to book, you need to check if tour on the \
selected date is still available;
--> checkNewBooking
--> preSave --> +1 participant

- Implement advanced authentication features: confirm user email, keep users logged in with refresh tokens, two-factor authentication, etc.

+++ Confirm user email +++ (implement activate email again --> user accidentially delete email)
activeEmail: {
  type: Boolean,
  default: false,
},
activeEmailToken: {
  type: String,
  select: false,
},
--> emailActivatedDate ?

+++ Refresh Token +++

--> Why we need Refresh Token?
--> https://www.udemy.com/course/nodejs-tutorial-and-projects-course/learn/lecture/29011806#questions/16122044
+ Access Token v/s Refresh Token
+ Resource Server v/s Authorization Server

--> req.headers['user-agent'] & req.ip
--> Session cookie --> used to track session of a user --> all the information that server need to regconize user

--> JWT_SECRET_ACCESS_TOKEN
--> JWT_SECRET_REFRESH_TOKEN

--> Send multiple cookies --> res.cookies() multiple times
--> use maxAge in cookie options
--> protect --> if accessToken --> next() --> else --> \
send new accessToken on the way in protect

--> Generate both cookies when create new accessToken using refreshToken

CHALLENGES WEBSITE

- Implement a sign up form, similar to login form;
- On the tour detail page, if a user has taken a tour, allow them add a review directly on the website. Implement a form for this.
- Hide the entire booking section on the detail page if current user has already booked the tour(also prevent duplicate bookings on the model);
- Implement "like tour" functionality, with fav tour page;

- On the user account page, implement the "My Reviews" page, \
wehere all reviews are displayed, and a user can edit them. \
(If you know REACT, this would be an amazing way to use \
the Natours API and train your skills!);

- For administrators, implement all the "Manage" pages, where they can CRUD tours, users, reviews and bookings.

--> Deploy Website on Railway
--> https://www.udemy.com/course/nodejs-express-mongodb-bootcamp/learn/lecture/15087388#questions/18696110

+++ URL +++
--> req.protocol
--> req.get('host')
--> req.origin
--> req.originalUrl

SECTION 14 - Deployment

1. Preparing our App for Deployment

--> npm install compression
--> Whenever we send a text response to a client, no matter if that' JSON or HTML code. \
With compression package, that text will be dramatically compressed
---
const compression = require('compression');
app.use(compression());
---

--> Turn off console.log()
--> Some console.log() needs to show in our log files

--> Use relative URL on client-side
--> Only works if using the same URL

--> .gitignore --> .cache/
git rm -r --cached <folder>

--> Create final compressed JavaScript bundle
"build:js": "parcel build ./public/js/index.js --out-dir ./public/js --out-file bundle.js --public-url ./"

--> git commit -m 'Prepared app for deployment'

2. Deploying app --> NODE_ENV=production

https://www.udemy.com/course/nodejs-express-mongodb-bootcamp/learn/lecture/15087432#questions/18696110
https://www.freecodecamp.org/news/how-to-deploy-nodejs-application-with-render/amp/

--> sudo npm install --location=global heroku
--> heroku login
--> "start": "node server.js"
--> "engines": {
  "node": ">=10.0.0"
}
--> process.env.PORT
--> test gzip compression

3. Testing for Secure HTTPS

--> app.enable('trust proxy')
--> secure: req.secure || req.headers['x-forwarded-proto'] === 'https'

4. Responding to a SIGTERM Signal

---
process.on('SIGTERM', () => {
  console.error('\n--- SIGTERM RECEIVED! Shutting down... ---\n');

  if (server) server.close(() => console.log('SIGTERM - Process terminated!'));
});
---

6. Implementing CORS - Cross-Origin Resouce Sharing

Domain A to Domain A --> Same-origin request
Domain A to Doamin B --> Cross-origin request

--> Call API on different URL --> Cross-Origin Request
--> npm install cors

---
const cors = require('cors');

cors() --> Access-Control-Allow-Origin *

// For all
app.use(cors());

// api.natours.com, front-end natours.com
app.use(cors({
  origin: 'https://www.natours.comn'
}));

// For route
app.use('/api/v1/tours', cors(), tourRouter);
---

--> Simple request --> Get and Post
--> Non-simple request --> Put, Patch, Delete or Request that sends Cookie or use nonstandard headers

--> Non-simple request requires preflight phase
--> Whenever there is a non-simple request, the browser will then automatically \
issue the preflight phase
--> Before the real request actually happens (like delete request), the browser \
first does an options request inorder to figure out if the actual request \
is safe to send

--> Server receives Options request (just like HTTP requests)
--> Sends back the same Access-Control-Allow-Origin header
--> So the browser knows the actual request is safe to perform and execute

---
app.options(*, cors());
// app.options('/api/v1/tours/:id', cors());
---

"engines": {
  "node": "^16"
}

7. Stripe Webhooks

--> Endpoint --> {{URL}}webhook-checkout
--> Event --> checkout.session.completed

--> app.js --> app.post('/webhook-checkout', webhookCheckout)
--> before app.user(express.json({ limit: '10kb' }))
--> Stripe function needs to read the body in the raw form

--> app.post('webhook-checkout', express.raw({
  type: 'application/json'
}), webhookCheckout)

--> change success_url, change route, controller

Flow: getCheckoutSession --> success_url --> webhookCheckout \
--> createBookingCheckout(session)
