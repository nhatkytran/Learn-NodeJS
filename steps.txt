SECTION - 6

1. app.js
2. npm install express
3. npm install nodemon --save-dev
4. "start": "nodemon app.js --inspect"
5. Handle POST - req.body (app.use(express.json() and app.use(express.urlencoded({ extended: true }))))
6. npm install morgan --> app.use(morgan('dev'))
7. Mount router
- app.get(< path >, callback)
- app.route(< path >).get(callback)
- app.use(< path >, router)
--> router.route(< sub - path>).get(callback)
8. app.js, server.js, controllers (tourController.js), routes (tourRoutes.js)
9. Use param middleware for validation
10. Chaining multiple middleware functions
11. Serving static files: app.use(express.static(< path >))
12. Environment variables: process.env
--> NODE_ENV=development nodemon server.js --inspect
--> Use config.env
npm install dotenv
dotenv.config({ path: < path > })
13. morgan --> run on development environment

SECTION - 8

1. Connect database with the Express Application
npm install mongoose
--> Mongoose --> ODM --> Object Data Modeling
--> Configuration: Database's password <PASSWORD>, Database's name
Options: { useNewUrlParser: true, useUnifiedTopology: true }
2. Create Schema and Model
3. MVC Architecture - models Folder
4. CRUD operations with real database
- Create --> model.create
- Read --> model.find, model.findById
- Update --> model.findByIdAndUpdate
- Delete --> model.findByIdAndDelete
5. Modeling the tours
6. Write script to import development data
--> import-dev-data.js
--> model.create(array)
--> model.deleteMany
process.argv
process.exit()
--import
--delete
7. Query string --> ?a=1&b=2 --> req.query
- Special query fields (page, sort, limit, fields)
- No need to exclude fields in query in Mongoose version 6 and above
--> Mongoose only cares if fields defined in Schema
- Understance chaining query
8. Advanced filtering
field[gt] = number
--> query throw CastError
9. Sorting -- 1 or more fields
--> By default, sort using _id --> more efficient
10. Limit field --> Project --> model.select
11. Pagination
12. Aliasing --> 5 best cheap tours --> sort=-ratingAverage,price
--> Middleware --> aliasTopTours
13. API Features
--> APIFeatures as the async function returning class APIFeatures
14. Aggregate Pipeline
--> getTourStats --> model.Aggregate
- $match
- $group
- $sort
- $match
--> Unwinding --> getMonthlyPlan
{ a: [1, 2, 3] }
-- Result --
{ a: 1 }, { a: 2 }, { a: 3 }
15. Virtual properties
schema definition
schema options --> {
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  id: false,
}
16. Middleware --> pre and post hooks (this vs docs)

-- Document --
npm install slugify
--> 'save' acts on .save() and .create()
--> this --> document
Schema --> slug: { type: String }

-- Query --
--> /^find/
--> this --> query
--> post --> docs
Schema --> secretTour: { type: Boolean, default: false }

- Aggregation --> Exclude secretTour

17. Validation --> Built-in & Custom
Compare value A with value B --> Can not update value A and value B at once
--> npm install validator
--> use regex to check if name only contains space and letter

SECTION - 9

1. Unhandled Routes
app.all('*', callback) --> status: fail
2. Global Error Handling Middleware --> Seaparation of Concerns --> status: error
--> Operational Errors (Exceptions)
--> Programming Errors
--> app.use((error, req, res, next) --> 4 arguments --> Express knows that this is Gloabl Error Handling Middleware)
--> next(< error >) --> Global Error Handling Middleware
3. Custom Errors
appError.js --> AppError --> statusCode, status, message
isOperational = true
Error.captureStackTrace(this, this.constructor)
errorController.js --> globalErrorHandler
new AppError vs new Error
4. catchAsync.js
5. 404 Not Found Errors
6. Errors: Development vs Production
--> Operational Error
7. Operational Error
Invalid ID (CastError)
Duplicate value --> code = 11000
ValidationError
8. Unhandled Rejections --> Wrong DB password, etc,... --> Asynchronous
process.exit(0 | 1); 0 --> Success; 1 --> Exception
9. Uncaught Exceptions
