SECTION - 6

1. app.js
2. npm install express
3. npm install nodemon --save-dev
4. "start": "nodemon app.js --inspect"
5. Handle POST - req.body (app.use(express.json() and app.use(express.urlencoded({ extended: true }))))
6. npm install morgan --> app.use(morgan('dev'))
7. Mount router
- app.get(< path >, callback)
- app.route(< path >).get(callback)
- app.use(< path >, router)
--> router.route(< sub - path>).get(callback)
8. app.js, server.js, controllers (tourController.js), routes (tourRoutes.js)
9. Use param middleware for validation
10. Chaining multiple middleware functions
11. Serving static files: app.use(express.static(< path >))
12. Environment variables: process.env
--> NODE_ENV=development nodemon server.js --inspect
--> Use config.env
npm install dotenv
dotenv.config({ path: < path > })
13. morgan --> run on development environment

SECTION - 8

1. Connect database with the Express Application
npm install mongoose
--> Mongoose --> ODM --> Object Data Modeling
--> Configuration: Database's password <PASSWORD>, Database's name
Options: { useNewUrlParser: true, useUnifiedTopology: true }
2. Create Schema and Model
3. MVC Architecture - models Folder
4. CRUD operations with real database
- Create --> model.create
- Read --> model.find, model.findById
- Update --> model.findByIdAndUpdate
- Delete --> model.findByIdAndDelete
5. Modeling the tours
6. Write script to import development data
--> import-dev-data.js
--> model.create(array)
--> model.deleteMany
process.argv
process.exit()
--import
--delete
7. Query string --> ?a=1&b=2 --> req.query
- Special query fields (page, sort, limit, fields)
- No need to exclude fields in query in Mongoose version 6 and above
--> Mongoose only cares if fields defined in Schema
- Understance chaining query
8. Advanced filtering
field[gt] = number
--> query throw CastError
9. Sorting -- 1 or more fields
--> By default, sort using _id --> more efficient
10. Limit field --> Project --> model.select
11. Pagination
12. Aliasing --> 5 best cheap tours --> sort=-ratingAverage,price
--> Middleware --> aliasTopTours
13. API Features
--> APIFeatures as the async function returning class APIFeatures
14. Aggregate Pipeline
--> getTourStats --> model.Aggregate
- $match
- $group
- $sort
- $match
--> Unwinding --> getMonthlyPlan
{ a: [1, 2, 3] }
-- Result --
{ a: 1 }, { a: 2 }, { a: 3 }
15. Virtual properties
schema definition
schema options --> {
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  id: false,
}
16. Middleware --> pre and post hooks (this vs docs)

-- Document --
npm install slugify
--> 'save' acts on .save() and .create() --> also works with findByIdAndUpdate
--> this --> document
Schema --> slug: { type: String }

-- Query --
--> /^find/
--> this --> query
--> post --> docs
Schema --> secretTour: { type: Boolean, default: false }

- Aggregation --> Exclude secretTour

17. Validation --> Built-in & Custom
Compare value A with value B --> Can not update value A and value B at once
--> npm install validator
--> use regex to check if name only contains space and letter

SECTION - 9

1. Unhandled Routes
app.all('*', callback) --> status: fail
2. Global Error Handling Middleware --> Seaparation of Concerns --> status: error
--> Operational Errors (Exceptions)
--> Programming Errors
--> app.use((error, req, res, next) --> 4 arguments --> Express knows that this is Gloabl Error Handling Middleware)
--> next(< error >) --> Global Error Handling Middleware
3. Custom Errors
appError.js --> AppError --> statusCode, status, message
isOperational = true
Error.captureStackTrace(this, this.constructor)
errorController.js --> globalErrorHandler
new AppError vs new Error
4. catchAsync.js
5. 404 Not Found Errors
6. Errors: Development vs Production
--> Operational Error
7. Operational Error
Invalid ID (CastError)
Duplicate value --> code = 11000
ValidationError
8. Unhandled Rejections --> Wrong DB password, etc,... --> Asynchronous
process.exit(0 | 1); 0 --> Success; 1 --> Exception
9. Uncaught Exceptions

SECTION - 10

1. Model and Create Users
--> npm install validator
2. Create User --> authController.js
--> signup --> convert password and passwordConfirm to String
3. Manage Password --> password encryption / password hashing
Create --> Schema Validation --> Pre hook --> Main query --> Post hook --> Send response
--> passwordConfirm validation --> set undefined --> not get save into database
--> Encrypt password
--> npm install bcryptjs --> bcrypt implementation for Javascript
--> bcryptHash
4. JWT
Signing up Users
--> npm install jsonwebtoken
--> signJWT
Logging in Users --> bcryptCompare
--> Sign token if user exists and password is correct (email and password)
- Check if email and password exist
- Check if email - user exists and password is correct --> password { select: false } --> select('+password')
- If everything ok, send token
--> select('password') --> select only field password
--> select('+password') --> select password (add up)
--> correctPassword --> bcrypt.compare
5. Protect Tour Routes --> 401 --> Unauthorized
--> Setting headers in Postman
--> Check authorization --> req.headers.authorization.startsWith('Bearer')
--> Get token --> Verify token --> decoded { id, iat, exp }
--> Handle JWT error --> Invalid JWT and Expired JWT (90d or 5)
JsonWebTokenError
TokenExpiredError
--> Check if user still exists
--> Check if user changed password after JWT was issued --> changePassword
passwordChangedAt { type: Date }
--> Grant access to protected routes --> req.user = currentUser --> next()
--> req travels from middleware to the next one --> put data on req
6. Advanced Postman setup --> Environment variables
--> {{URL}}
--> {{jwt}} --> Postman --> Tests --> pm.environment.set("jwt", pm.response.json().token);
7. Authorization: User - Roles and Permissions --> 403: Forbidden
role { type: String, enum: ['user', 'guide', 'lead-guide', 'admin'], default: 'user' }
protect --> restrictTo --> main route (restrictTo('admin', 'lead-guide'))
8. Reset Token --> forgotPassword (POST) --> resetPassword (PATCH)
+++ forgotPassword +++
--> createPasswordResetToken --> crypto.randomBytes & crypto.createHash
--> passwordResetToken { type: String, select: false }, passwordResetExpires { type: Date, select: false }
--> resetToken & passwordResetToken
--> modify document --> save document --> document.save({ validateModifiedOnly: true })
--> create (new fields) --> update(old fields) --> save (add new fields)
+++ send reset token via email +++
--> npm install nodemailer --> configure to send email in NodeJS
--> create transporter --> configure options --> send email
--> user Mailtrap to send email
--> handle error sending email
+++ resetPassword +++
--> get email & token --> hashed token --> find user { email, passwordResetToken, passwordResetExpires }
--> check password and passwordConfirm --> validate --> save
--> update passwordChangedAt --> this.isModified(< field >) & this.isNew
--> send jwt
9. Update user password
--> user 'save' instead of 'findByIdAndUpdate' case 'findByIdAndUpdate' has some quirk with validation
--> createSendToken
10. Update user's data --> updateMe --> use findByIdAndUpdate --> use filterObject
11. Delete user
--> active { type: Boolean, default: true, select: false } --> deleteMe --> active = false
--> user query middleware to prevent finding inactive user
10. + 11. route /me for both update and delete
GDPR --> General Data Protection Regulation
12. Security
--> Compromised Database
--> Brute Force Attacks
--> Cross-site Scripting (XSS) Attacks
--> Denial Of Service (DOS) Attacks
--> NoSQL Query Injection
...
12.1. Sending JWT via Cookie
--> JWT_COOKIE_EXPIRES_IN
--> Remove password when create new user
12.2. Rate limiting
--> npm install express-rate-limit --> rateLimit
--> configure limiter --> app.use('/api', limiter);
12.3. Security HTTP Headers
--> npm install helmet --> helmet
--> app.use(helmet()) --> set headers --> place on top of middleware stack
--> Limit data from body --> app.use(express.json({ limit: '10kb' }));
--> CORS --> Whho can use API
12.4 Data sanitization
--> Defend against NoSQL Query Injection --> npm install mongo-express-sanitize --> mongoSanitize
--> "email": { "$gt": "" }
--> Defend against Cross - Site Scripting --> npm install xss-clean --> xss
--> "name": "<div></div>"
(
  app.use(express.json({ limit: '10kb' }));
  app.use(express.urlencoded({ extended: true }));
) --> Recieve data
--> Clean data from malicious code
12.5. Prevent parameter pollution
--> sort&sort
--> npm install hpp
--> app.use(hpp({
  whitelist: ['duration', 'ratingsQuantity', 'ratingsAverage',
  'maxGroupSize', 'difficulty', 'price']
}));
